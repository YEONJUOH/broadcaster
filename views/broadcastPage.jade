doctype html
html(lang='en')
    head
        meta(charset='UTF-8')
        title Title
        style.
            video {
                width:100%;
            }
            html,body{
                height: 100%;
            }
        link(rel='stylesheet', type='text/css', href='/stylesheets/bootstrap.min.css')
    body
        .bs-component
            nav.navbar.navbar-default
                .container-fluid
                    .navbar-header
                        button.navbar-toggle.collapsed(type='button', data-toggle='collapse', data-target='#bs-example-navbar-collapse-1')
                            span.sr-only Toggle navigation
                            span.icon-bar
                            span.icon-bar
                            span.icon-bar
                        a.navbar-brand(href='#') NursNars
            div(style='width:90%;margin:0 auto;padding-top:7px;')
                div(style='width:70%;margin-right:0px;float:left')
                    #videos-container(style='width:100%;margin-right:0px')
                    div(style='background:#ffffff;padding:5px;')
                        h3 방송제목
                        div
                            span 상품명
                            span 최저 입찰가
                        input#broadcast-id(type='hidden', placeholder='broadcast-id', value='undefined')
                div(style='width:30%;height100%;float:left;')
                    div(style='width:95%;height:600px;margin:0 auto;background:#ffffff;padding-top:5px;')
                        h4(style='width:95%;margin:0 auto;background:#666666;color:#ffffff;text-align:center;padding:4px;') 입찰 희망
                        div(style='text-align:center;width:95%;margin:10px auto;border-bottom:1px solid') 입찰 희망 내역이 없습니다.
                        .chat-output(style='width:95%;margin:10px auto;height:450px;background:#d9d9d9')
                        div(style='width:95%;margin:0 auto;')
                            button(style='float:right') 입력
                            .stretcher(style='overflow:hidden')
                                input#input-text-chat(type='text', style='width:100%')
                        div(style='width:95%;margin:5px auto;')
                            button(style='width:100%;') 입찰하기
    script(src='/socket.io/socket.io.js')
    script(src='/javascripts/RTCMultiConnection.js')
    script.
        var socket = io.connect();
        // using single socket for RTCMultiConnection signaling
        //script for chat connection
        var chatConnection = new RTCMultiConnection();
        chatConnection.socketURL ='/';
        chatConnection.socketMessageEvent = 'textchat-plus-fileshare-demo';
        chatConnection.session = {
            data: true
        };
        chatConnection.sdpConstraints.mandatory = {
            OfferToReceiveAudio: false,
            OfferToReceiveVideo: false
        };
        chatConnection.onmessage = appendDIV;
        document.getElementById('input-text-chat').onkeyup = function(e) {
            if (e.keyCode != 13) return;
            // removing trailing/leading whitespace
            this.value = this.value.replace(/^\\s+|\s+$/g, '');
            if (!this.value.length) return;
            chatConnection.send(this.value);
            appendDIV(this.value);
            this.value = '';
        };
        var chatContainer = document.querySelector('.chat-output');
        function appendDIV(event) {
            var div = document.createElement('div');
            div.innerHTML = event.data || event;
            chatContainer.insertBefore(div, chatContainer.firstChild);
            div.tabIndex = 0;
            div.focus();
            document.getElementById('input-text-chat').focus();
        }
        var onMessageCallbacks = {};
        socket.on('message', function(data) {
            if (data.sender == connection.userid) return;
            if (onMessageCallbacks[data.channel]) {
                onMessageCallbacks[data.channel](data.message);
            };
        });
        // initializing RTCMultiConnection constructor.
        function initRTCMultiConnection(userid) {
            var connection = new RTCMultiConnection();
            connection.body = document.getElementById('videos-container');
            connection.channel = connection.sessionid = connection.userid = userid || connection.userid;
            connection.sdpConstraints.mandatory = {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: true
            };
            // using socket.io for signaling
            connection.openSignalingChannel = function(config) {
                var channel = config.channel || this.channel;
                onMessageCallbacks[channel] = config.onmessage;
                if (config.onopen) setTimeout(config.onopen, 1000);
                return {
                    send: function(message) {
                        socket.emit('message', {
                            sender: connection.userid,
                            channel: channel,
                            message: message
                        });
                    },
                    channel: channel
                };
            };
            connection.onMediaError = function(error) {
                alert(JSON.stringify(error));
            };
            return connection;
        }
        // this RTCMultiConnection object is used to connect with existing users
        var connection = initRTCMultiConnection();
        connection.getExternalIceServers = false;
        connection.onstream = function(event) {
            connection.body.appendChild(event.mediaElement);
            if (connection.isInitiator == false && !connection.broadcastingConnection) {
                // "connection.broadcastingConnection" global-level object is used
                // instead of using a closure object, i.e. "privateConnection"
                // because sometimes out of browser-specific bugs, browser
                // can emit "onaddstream" event even if remote user didn't attach any stream.
                // such bugs happen often in chrome.
                // "connection.broadcastingConnection" prevents multiple initializations.
                // if current user is broadcast viewer
                // he should create a separate RTCMultiConnection object as well.
                // because node.js server can allot him other viewers for
                // remote-stream-broadcasting.
                connection.broadcastingConnection = initRTCMultiConnection(connection.userid);
                // to fix unexpected chrome/firefox bugs out of sendrecv/sendonly/etc. issues.
                connection.broadcastingConnection.onstream = function() {};
                connection.broadcastingConnection.session = connection.session;
                connection.broadcastingConnection.attachStreams.push(event.stream); // broadcast remote stream
                connection.broadcastingConnection.dontCaptureUserMedia = true;
                // forwarder should always use this!
                connection.broadcastingConnection.sdpConstraints.mandatory = {
                    OfferToReceiveVideo: false,
                    OfferToReceiveAudio: false
                };
                connection.broadcastingConnection.open({
                    dontTransmit: true
                });
            }
        };
        // ask node.js server to look for a broadcast
        // if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
        // if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
        /*document.getElementById('open-or-join').onclick = function() {
         var broadcastid = document.getElementById('broadcast-id').value;
         if (broadcastid.replace(/^\\\\\s+|\s+$/g, '').length <= 0) {
         alert('Please enter broadcast-id');
         document.getElementById('broadcast-id').focus();
         return;
         }
         this.disabled = true;
         connection.session = {
         video: 'Audio+Video',
         //video: document.getElementById('broadcast-options').value.indexOf('Video') !== -1,
         //screen: document.getElementById('broadcast-options').value.indexOf('Screen') !== -1,
         //audio: document.getElementById('broadcast-options').value.indexOf('Audio') !== -1,
         oneway: true
         };
         socket.emit('join-broadcast', {
         broadcastid: broadcastid,
         userid: connection.userid,
         typeOfStreams: connection.session
         });
         };
         */
        var broadcastid = document.getElementById('broadcast-id').value;
        var start = function() {
            if (broadcastid.replace(/^\\\\\s+|\s+$/g, '').length <= 0) {
                alert('Please enter broadcast-id');
                document.getElementById('broadcast-id').focus();
                return;
            }
            this.disabled = true;
            connection.session = {
                video: 'Audio+Video',
                //video: document.getElementById('broadcast-options').value.indexOf('Video') !== -1,
                //screen: document.getElementById('broadcast-options').value.indexOf('Screen') !== -1,
                //audio: document.getElementById('broadcast-options').value.indexOf('Audio') !== -1,
                oneway: true
            };
            socket.emit('join-broadcast', {
                broadcastid: broadcastid,
                userid: connection.userid,
                typeOfStreams: connection.session
            });
        };
        start();
        // this event is emitted when a broadcast is already created.
        socket.on('join-broadcaster', function(broadcaster, typeOfStreams) {
            connection.session = typeOfStreams;
            connection.channel = connection.sessionid = broadcaster.userid;
            connection.sdpConstraints.mandatory = {
                OfferToReceiveVideo: !!connection.session.video,
                OfferToReceiveAudio: !!connection.session.audio
            };
            chatConnection.join(broadcastid+"chat");
            connection.join({
                sessionid: broadcaster.userid,
                userid: broadcaster.userid,
                extra: {},
                session: connection.session
            });
        });
        // this event is emitted when a broadcast is absent.
        socket.on('start-broadcasting', function(typeOfStreams) {
            // host i.e. sender should always use this!
            connection.sdpConstraints.mandatory = {
                OfferToReceiveVideo: false,
                OfferToReceiveAudio: false
            };
            //chat room open
            chatConnection.open(broadcastid +"chat");
            connection.session = typeOfStreams;
            connection.open({
                dontTransmit: true
            });
            if (connection.broadcastingConnection) {
                // if new person is given the initiation/host/moderation control
                connection.broadcastingConnection.close();
                connection.broadcastingConnection = null;
            }
        });
        window.onbeforeunload = function() {
            // Firefox is weird!
            document.getElementById('open-or-join').disabled = false;
        };
